import { Well, PlateFormat, ControlType, ConcentrationUnit, CheckerboardConfig } from '../types';
import { COMPOUND_COLORS } from '../constants';
import { formatConcentration, getContrastingTextColor, calculateCheckerboardWellColor } from '../utils.js';

const getWellLabel = (well: Well): string => {
    if (well.controlType === ControlType.POSITIVE || well.controlType === ControlType.NEGATIVE) {
        return `${well.controlType} Control`;
    }
    if (well.compound && well.compound.trim()) {
        return well.compound.trim();
    }
    return ''; // Represents an empty or unlabeled well
};

const generateCompoundColorMap = (plateData: Well[]): Map<string, string> => {
    const colorMap = new Map<string, string>();
    const uniqueCompounds = new Set<string>();

    plateData.forEach(well => {
        const label = getWellLabel(well);
        if (label) {
            uniqueCompounds.add(label);
        }
    });

    const specialColors: { [key: string]: string } = {
        'Positive Control': '#1f78b4', // A distinct blue
        'Negative Control': '#e31a1c', // A distinct red
        'Growth Control': '#2ca02c' // A distinct green
    };

    let colorIndex = 0;
    // Sort for consistent color assignment
    for (const compound of Array.from(uniqueCompounds).sort()) {
        if (specialColors[compound]) {
            colorMap.set(compound, specialColors[compound]);
        } else if (!colorMap.has(compound)) {
            // Find a color that hasn't been used by special cases
            let assignedColor: string;
            do {
                assignedColor = COMPOUND_COLORS[colorIndex % COMPOUND_COLORS.length];
                colorIndex++;
            } while (Object.values(specialColors).includes(assignedColor));
            
            colorMap.set(compound, assignedColor);
        }
    }
    return colorMap;
};

const detectCheckerboardConfig = (plateData: Well[]): CheckerboardConfig | null => {
    const comboWell = plateData.find(w => w.compound.includes(' + '));
    if (!comboWell) return null;

    const nameParts = comboWell.compound.split(' + ');
    if (nameParts.length !== 2) return null;
    const drugAName = nameParts[0].trim();
    const drugBName = nameParts[1].trim();

    const highestAWell = plateData.find(w => w.id === 'A1' && w.compound === drugAName);
    const highestBWell = plateData.find(w => w.id === 'H12' && w.compound === drugBName);
    
    if (!highestAWell || !highestBWell || highestAWell.concentration === 0 || highestBWell.concentration === 0) {
        return null; // Not a standard checkerboard generated by our tool
    }

    const nextAWell = plateData.find(w => w.id === 'B1' && w.compound === drugAName);
    let factor = 2; // Default dilution factor
    if (nextAWell && nextAWell.concentration > 0) {
        const calculatedFactor = highestAWell.concentration / nextAWell.concentration;
        if (calculatedFactor > 1) {
            factor = calculatedFactor;
        }
    }

    return {
        drugAName,
        drugBName,
        maxConcA: highestAWell.concentration,
        maxConcB: highestBWell.concentration,
        factor,
        colorA: '#38bdf8', // tailwind sky-400
        colorB: '#facc15', // tailwind yellow-400
        mwA: highestAWell.mw,
        mwB: highestBWell.mw,
    };
};


const generateSvgString = (plateData: Well[], plateFormat: PlateFormat, colorMap: Map<string, string>, concentrationUnit: ConcentrationUnit, checkerboardConfig: CheckerboardConfig | null): { svg: string, width: number, height: number } => {
    const PADDING = 40;
    const TITLE_HEIGHT = 80; // Increased height to accommodate strain info
    const WELL_RADIUS = 20; // Increased radius for text
    const WELL_DIAMETER = WELL_RADIUS * 2;
    const WELL_SPACING = 10;
    const FONT_SIZE_LABEL = 14;
    const FONT_SIZE_TITLE = 24;
    const FONT_SIZE_SUBTITLE = 16;
    const FONT_SIZE_LEGEND = 14;
    const FONT_SIZE_WELL = 9; // Font size for text inside wells
    
    const GRID_X_OFFSET = PADDING + 30;
    const GRID_Y_OFFSET = PADDING + TITLE_HEIGHT;
    
    const plateWidth = plateFormat.cols * (WELL_DIAMETER + WELL_SPACING) - WELL_SPACING;
    const plateHeight = plateFormat.rows * (WELL_DIAMETER + WELL_SPACING) - WELL_SPACING;

    // --- Legend Calculation ---
    const mixLegendId = "mixGradient";
    let legendItems: [string, string][];

    if (checkerboardConfig) {
        legendItems = [];
        legendItems.push([checkerboardConfig.drugAName, checkerboardConfig.colorA]);
        legendItems.push([checkerboardConfig.drugBName, checkerboardConfig.colorB]);
        legendItems.push([`${checkerboardConfig.drugAName} + ${checkerboardConfig.drugBName}`, `url(#${mixLegendId})`]);

        const otherCompounds = new Set<string>();
        plateData.forEach(well => {
            const label = getWellLabel(well);
            if (label && label !== checkerboardConfig.drugAName && label !== checkerboardConfig.drugBName && !label.includes('+')) {
                otherCompounds.add(label);
            }
        });
        otherCompounds.forEach(compound => {
             const color = colorMap.get(compound);
             if (color) {
                legendItems.push([compound, color]);
             }
        });
    } else {
        legendItems = Array.from(colorMap.entries());
    }
    
    const LEGEND_X_OFFSET = GRID_X_OFFSET + plateWidth + 60;
    const LEGEND_Y_OFFSET = GRID_Y_OFFSET;
    const LEGEND_ITEM_HEIGHT = 25;
    const LEGEND_CIRCLE_RADIUS = 8;
    const LEGEND_TEXT_OFFSET = 20;
    let maxLegendWidth = 0;
    
    // Create a temporary element to measure text width accurately
    const svgRuler = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    const textRuler = document.createElementNS("http://www.w3.org/2000/svg", "text");
    textRuler.style.fontFamily = "sans-serif";
    textRuler.style.fontSize = `${FONT_SIZE_LEGEND}px`;
    svgRuler.appendChild(textRuler);
    document.body.appendChild(svgRuler);
    
    legendItems.forEach(([label]) => {
        textRuler.textContent = label;
        const textWidth = textRuler.getComputedTextLength();
        if (textWidth > maxLegendWidth) {
            maxLegendWidth = textWidth;
        }
    });
    document.body.removeChild(svgRuler);

    const legendTitleWidth = 100; // Approx for "Compound"
    const legendWidth = Math.max(legendTitleWidth, maxLegendWidth + LEGEND_TEXT_OFFSET + LEGEND_CIRCLE_RADIUS * 2);
    const legendHeight = (legendItems.length + 1) * LEGEND_ITEM_HEIGHT;
    
    // --- Final SVG Dimensions ---
    const totalWidth = LEGEND_X_OFFSET + legendWidth + PADDING;
    const totalHeight = Math.max(
        GRID_Y_OFFSET + plateHeight, 
        LEGEND_Y_OFFSET + legendHeight
    ) + PADDING;

    let svg = `<svg width="${totalWidth}" height="${totalHeight}" xmlns="http://www.w3.org/2000/svg" style="background-color: white; font-family: sans-serif; font-size: ${FONT_SIZE_LABEL}px;">`;
    
    if (checkerboardConfig) {
        svg += `
        <defs>
            <linearGradient id="${mixLegendId}" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%" style="stop-color:${checkerboardConfig.colorA};" />
                <stop offset="100%" style="stop-color:${checkerboardConfig.colorB};" />
            </linearGradient>
        </defs>`;
    }

    // Extract strain information
    const strains = new Set<string>();
    plateData.forEach(well => {
        if (well.strain && well.strain.trim()) {
            strains.add(well.strain.trim());
        }
    });
    const strainInfo = Array.from(strains).join(', ');

    // Title
    svg += `<text x="${PADDING}" y="${PADDING + 10}" font-size="${FONT_SIZE_TITLE}px" font-weight="bold" fill="black">96-well Plate Layout</text>`;
    
    // Strain subtitle
    if (strainInfo) {
        svg += `<text x="${PADDING}" y="${PADDING + 35}" font-size="${FONT_SIZE_SUBTITLE}px" fill="black">Strain: ${strainInfo}</text>`;
    }

    // Column Headers
    for (let i = 0; i < plateFormat.cols; i++) {
        const x = GRID_X_OFFSET + i * (WELL_DIAMETER + WELL_SPACING) + WELL_RADIUS;
        svg += `<text x="${x}" y="${GRID_Y_OFFSET - WELL_RADIUS - 5}" text-anchor="middle" dominant-baseline="middle" fill="black">${plateFormat.colLabels[i]}</text>`;
    }

    // Row Headers
    for (let i = 0; i < plateFormat.rows; i++) {
        const y = GRID_Y_OFFSET + i * (WELL_DIAMETER + WELL_SPACING) + WELL_RADIUS;
        svg += `<text x="${GRID_X_OFFSET - WELL_RADIUS - 10}" y="${y}" text-anchor="middle" dominant-baseline="middle" fill="black">${plateFormat.rowLabels[i]}</text>`;
    }
    
    // Wells
    plateData.forEach(well => {
        const row = plateFormat.rowLabels.indexOf(well.id.charAt(0));
        const col = parseInt(well.id.substring(1), 10) - 1;

        if (row !== -1 && col !== -1) {
            const cx = GRID_X_OFFSET + col * (WELL_DIAMETER + WELL_SPACING) + WELL_RADIUS;
            const cy = GRID_Y_OFFSET + row * (WELL_DIAMETER + WELL_SPACING) + WELL_RADIUS;
            
            let fillColor: string | null = null;
            if (checkerboardConfig) {
                fillColor = calculateCheckerboardWellColor(well, checkerboardConfig, plateFormat);
            }
            if (!fillColor) {
                const label = getWellLabel(well);
                fillColor = colorMap.get(label) || '#FFFFFF';
            }

            svg += `<circle cx="${cx}" cy="${cy}" r="${WELL_RADIUS}" fill="${fillColor}" stroke="black" stroke-width="1.5" />`;

            const textColor = getContrastingTextColor(fillColor);

            // Add concentration text inside the well
            if (checkerboardConfig && well.compound.includes(' + ')) {
                // Combination well: show both concentrations
                const colIndex = plateFormat.colLabels.indexOf(well.id.substring(1));
                const exponent = (plateFormat.colLabels.length - 1) - colIndex;
                const concB_uM = checkerboardConfig.maxConcB / Math.pow(checkerboardConfig.factor, exponent);

                const formattedConcA = formatConcentration(well.concentration, checkerboardConfig.mwA, concentrationUnit).replace(' ', '');
                const formattedConcB = formatConcentration(concB_uM, checkerboardConfig.mwB, concentrationUnit).replace(' ', '');
                
                // Use a smaller font size for two lines
                const FONT_SIZE_WELL_SMALL = 8;

                svg += `<text x="${cx}" y="${cy}" text-anchor="middle" dominant-baseline="middle" fill="${textColor}" font-size="${FONT_SIZE_WELL_SMALL}px" font-weight="bold">`;
                svg += `<tspan x="${cx}" dy="-0.4em">${formattedConcA}</tspan>`;
                svg += `<tspan x="${cx}" dy="1.2em">${formattedConcB}</tspan>`;
                svg += `</text>`;

            } else if (well.concentration > 0) {
                // Single drug well
                const formattedConc = formatConcentration(well.concentration, well.mw, concentrationUnit);
                const [value, unit] = formattedConc.split(' ');
                
                svg += `<text x="${cx}" y="${cy}" text-anchor="middle" dominant-baseline="middle" fill="${textColor}" font-size="${FONT_SIZE_WELL}px" font-weight="bold">`;
                svg += `<tspan x="${cx}" dy="-0.2em">${value}</tspan>`;
                svg += `<tspan x="${cx}" dy="1.2em">${unit || ''}</tspan>`;
                svg += `</text>`;
            }
        }
    });
    
    // Legend
    svg += `<text x="${LEGEND_X_OFFSET}" y="${LEGEND_Y_OFFSET - 20}" font-size="16px" font-weight="bold" fill="black">Legend</text>`;
    legendItems.forEach(([label, color], index) => {
        const y = LEGEND_Y_OFFSET + index * LEGEND_ITEM_HEIGHT;
        svg += `<circle cx="${LEGEND_X_OFFSET + LEGEND_CIRCLE_RADIUS}" cy="${y}" r="${LEGEND_CIRCLE_RADIUS}" fill="${color}" stroke="black" stroke-width="1" />`;
        svg += `<text x="${LEGEND_X_OFFSET + LEGEND_CIRCLE_RADIUS + LEGEND_TEXT_OFFSET}" y="${y}" dominant-baseline="middle" fill="black">${label}</text>`;
    });

    svg += '</svg>';
    return { svg, width: totalWidth, height: totalHeight };
};


export const exportPlateToPng = (plateData: Well[], plateFormat: PlateFormat, concentrationUnit: ConcentrationUnit) => {
    const colorMap = generateCompoundColorMap(plateData);
    const checkerboardConfig = detectCheckerboardConfig(plateData);
    const { svg, width, height } = generateSvgString(plateData, plateFormat, colorMap, concentrationUnit, checkerboardConfig);

    const canvas = document.createElement('canvas');
    canvas.width = width * 2; // Render at 2x for higher resolution
    canvas.height = height * 2;
    const ctx = canvas.getContext('2d');
    
    if (!ctx) {
        alert("Canvas context could not be created.");
        return;
    }

    ctx.scale(2, 2); // Scale context for higher DPI

    const img = new Image();
    const svgBlob = new Blob([svg], { type: 'image/svg+xml;charset=utf-8' });
    const url = URL.createObjectURL(svgBlob);

    img.onload = () => {
        ctx.drawImage(img, 0, 0);
        URL.revokeObjectURL(url);
        
        const pngUrl = canvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.download = 'platecrafter_layout.png';
        link.href = pngUrl;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    };
    
    img.onerror = (e) => {
        console.error("Error loading SVG image for conversion:", e);
        URL.revokeObjectURL(url);
        alert("Failed to load the generated SVG image. Cannot export to PNG.");
    };

    img.src = url;
};